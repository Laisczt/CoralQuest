<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/CoralQuest/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/CoralQuest/" rel="alternate" type="text/html" /><updated>2024-09-22T22:11:23-03:00</updated><id>http://localhost:4000/CoralQuest/feed.xml</id><title type="html">Coral Quest</title><subtitle>Coral quest é um jogo desenvolvido por alunos de Engenharia de Software da UnB-FGA como um passo intermediário para desenvolvimento de jogos em Unity a partir do aprendizado dos básicos da engine</subtitle><entry><title type="html">Multiplas Câmeras</title><link href="http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras.html" rel="alternate" type="text/html" title="Multiplas Câmeras" /><published>2024-09-07T12:00:00-03:00</published><updated>2024-09-07T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras.html"><![CDATA[<p>Existem várias formas de utilizar várias câmeras simultaneamente no Unity.</p>

<p>Coral Quest utiliza uma câmera principal que vê o nível, e uma câmera de background que somente vê o plano de fundo.</p>

<p>Para alcançar esse efeito, posicione sua tela de fundo em algum lugar em sua cena com uma câmera apontando para ela (garanta que a câmera não possua a tag ‘Main Camera’)</p>

<p><img src="../../../img/telacam.png" alt="Camera e tela de fundo em cena" /></p>

<p>Em seguida, crie um Render Texture na aba de projeto, e o configure com as dimensões desejadas</p>

<p><img src="../../../img/rendertexture.png" alt="Propriedades Render Texture" /></p>

<p>Passe a render texture criada como textura de output da camera</p>

<p><img src="../../../img/outputtexture.png" alt="Atribuição output texture" /></p>

<p>Crie um canvas como objeto filho da câmera principal, e defina o modo de renderização como Screen Space - Camera</p>

<p><img src="../../../img/cameracanvas.png" alt="Canvas filho" /></p>

<p>Crie uma Raw Image como filha do canvas em UI &gt; Raw Image e utilize a render texture como textura</p>

<p><img src="../../../img/texturecanvas.png" alt="Textura no Canvas" /></p>

<p>Por fim, defina a ancoração da imagem para stretch em ambas as direções, segurando alt para copiar a posição</p>

<p><img src="../../../img/anchorpresets.png" alt="Anchor Presets" /></p>

<p>Veja também outras formas de utilizar múltiplas câmeras:</p>

<p><a href="https://www.youtube.com/watch?v=4A-ptevH6-w">https://www.youtube.com/watch?v=4A-ptevH6-w</a></p>

<p><a href="https://www.youtube.com/watch?v=bbnVpPiQ_rU">https://www.youtube.com/watch?v=bbnVpPiQ_rU</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Existem várias formas de utilizar várias câmeras simultaneamente no Unity.]]></summary></entry><entry><title type="html">Interfaces</title><link href="http://localhost:4000/CoralQuest/2024/09/06/Interfaces.html" rel="alternate" type="text/html" title="Interfaces" /><published>2024-09-06T12:00:00-03:00</published><updated>2024-09-06T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/06/Interfaces</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/06/Interfaces.html"><![CDATA[<p>Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.</p>

<p>Pegue por exemplo, Um ataque do jogador que pode atingir inimigos e objetos quebráveis, podemos implementá-lo da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IDamageable</span>
<span class="p">{</span>
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>No script do ataque</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">OnTriggerEnter2D</span><span class="p">(</span><span class="n">Collider2D</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hit</span> <span class="p">=</span> <span class="n">collision</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">IDamageable</span><span class="p">&gt;()</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hit</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hit</span><span class="p">.</span><span class="nf">Damage</span><span class="p">(</span><span class="n">dano</span><span class="p">);</span> 
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>No script do inimigo</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span><span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">IDamageable</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">health</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
	<span class="cm">/* Implementação da classe
	.
	.
	.
	*/</span>
	
	
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">health</span> <span class="p">-=</span> <span class="n">amount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>No script do objeto quebrável</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Crate</span><span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">IDamageable</span>
<span class="p">{</span>
	<span class="cm">/* Implementação da classe
	.
	.
	.
	*/</span>
	
	<span class="k">void</span> <span class="nf">BreakObject</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="nf">Destroy</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="nf">BreakObject</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.]]></summary></entry><entry><title type="html">Corotinas</title><link href="http://localhost:4000/CoralQuest/2024/09/05/Corotinas.html" rel="alternate" type="text/html" title="Corotinas" /><published>2024-09-05T12:00:00-03:00</published><updated>2024-09-05T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/05/Corotinas</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/05/Corotinas.html"><![CDATA[<p>Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.</p>

<p>Corotinas são declaradas como funçãos com tipo IEnumerator e devem ser chamadas com a função StartCoroutine().</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">DashForward</span><span class="p">(</span><span class="m">10</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">IEnumerator</span> <span class="nf">DashForward</span><span class="p">(</span><span class="kt">int</span> <span class="n">duracao</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
	Força o jogador a se mover rapidamente para a direita por alguns frames
*/</span>
	<span class="n">mRigidBody</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RigidBody2D</span><span class="p">&gt;();</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">duracao</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">{</span>	
		<span class="n">mRigidBody</span><span class="p">.</span><span class="n">velocity</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="m">5</span><span class="p">;</span>
		<span class="n">duracao</span><span class="p">--;</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Dentro de uma corotina, devemos usar a palavra ´yield´ para indicar onde a execução será pausada até o próximo frame. Podemos também utilizar outros valores no lugar de null, entre eles: ´yield return new WaitForFixedUpdate()´ retomará a execução no proximo frame de fixed update, ‘yield return new WaitForSeconds(3)’ retomará após 3 segundos.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.]]></summary></entry><entry><title type="html">Cenas Aditivas</title><link href="http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas.html" rel="alternate" type="text/html" title="Cenas Aditivas" /><published>2024-09-04T12:00:00-03:00</published><updated>2024-09-04T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas.html"><![CDATA[<p>A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.</p>

<p>Uma forma mais versátil de fazer nossa UI é colocá-la numa cena própria, e então carregar tal cena de forma aditiva(ou, por cima) da cena da fase.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">LoadUI</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">IEnumerator</span> <span class="nf">LoadUI</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">_UIScene</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"UI"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">LoadSceneParameters</span><span class="p">(</span><span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">));</span>   <span class="c1">// Carrega a UI por cima da cena inicial</span>

        <span class="k">while</span><span class="p">(!</span><span class="n">_UIScene</span><span class="p">.</span><span class="n">isLoaded</span><span class="p">)</span>   <span class="c1">// Espera até a UI estar carregada</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Note que carregar cenas aditivamente pode demorar um pouco, por isso é recomendado usar uma <a href="../../../2024/09/05/Corotinas.html">Corotina</a></p>

<p>A desvantagem desse método é que referências entre objetos da UI e da fase devem ser tratadas com mais atenção. Utilizar o <a href="../../../2024/09/03/Singleton.html">Padrão Singleton</a>, e tags pode ajudar bastante. Outra forma é utilizar a referência a cena retornada pela função LoadScene().</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">_UIScene</span><span class="p">.</span><span class="nf">GetRootGameObjects</span><span class="p">()[</span><span class="m">0</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"Health Bar"</span><span class="p">).</span><span class="nf">SetFullHP</span><span class="p">();</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.]]></summary></entry><entry><title type="html">Padrão Singleton</title><link href="http://localhost:4000/CoralQuest/2024/09/03/Singleton.html" rel="alternate" type="text/html" title="Padrão Singleton" /><published>2024-09-03T12:00:00-03:00</published><updated>2024-09-03T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/03/Singleton</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/03/Singleton.html"><![CDATA[<p>Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.</p>

<p>O GameManager possui uma característica que pode nos ajudar a referênciá-lo de forma eficiente, isto é o fato que só pode existir um destes objetos ativos em um dado momento. Isso nos possibilita o uso do padrão Singleton de design.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">GameManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="c1">//</span>
	<span class="c1">//    ...</span>
	<span class="c1">//</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">GameManager</span> <span class="n">Instance</span><span class="p">;</span>
	
	<span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>	<span class="c1">// Awake ocorre ainda antes do Start()</span>
	<span class="p">{</span>
		<span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="c1">//</span>
	<span class="c1">//    ...</span>
	<span class="c1">//</span>

<span class="p">}</span></code></pre></figure>

<p>Referências ao GameManager podem então ser feitas assim:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">GameManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
		<span class="c1">// =&gt; 3</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://gamedevbeginner.com/singletons-in-unity-the-right-way/">Mais sobre o padrão Singleton</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.]]></summary></entry><entry><title type="html">Helper Classes &amp;amp; Extension Methods</title><link href="http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao.html" rel="alternate" type="text/html" title="Helper Classes &amp;amp; Extension Methods" /><published>2024-09-02T12:00:00-03:00</published><updated>2024-09-02T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao.html"><![CDATA[<p>Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.</p>

<p>Uma helper Class é uma classe estática (pode ser chamada de qualquer parte do código) que guarda esse tipo de função que é útil em vários cenários.</p>

<p>O Código a seguir implementa uma helper class com uma função que eleva um número ao quadrado e o divide por 3</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Helpers</span> <span class="c1">// note que essa classe não herda de MonoBehaviour</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="kt">float</span> <span class="nf">SquareAndCut3</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Essa função pode então ser utilizada em outras classes:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
	<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">Helpers</span><span class="p">.</span><span class="nf">SquareAndCut3</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
		<span class="n">a</span><span class="p">++;</span>
		<span class="c1">// Imprime ao console o resultado da equação todo frame e incrementa o valor de entrada</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Uma ideia similar à de Helper Classes é Extension Classes.</p>

<p>Nós não temos acesso ao código das classes já presentes no Unity (ex.: Transform, AudioSource, Vector3), porém existem situações em que seria conveniente adicionar uma função à uma dessas classes.</p>

<p>Por exemplo, você pode achar que caso queira rotacionar um Vector2 em um ângulo específico, deve existir uma função Vector2.Rotate(angulo), porém essa função não existe.
Uma solução para isso seria implementar uma função RotateVector2() numa helper class, porém há uma solução mais elegante utilizando uma classe de extenção.:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ExtensionMethods</span>
<span class="p">{</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Rotate</span><span class="p">(</span><span class="k">this</span> <span class="n">Vector2</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">float</span> <span class="n">delta</span><span class="p">)</span> 	<span class="c1">// O termo 'this' no primeiro argumento define que isso é uma extensão da classe Vector2</span>
	<span class="p">{</span>
		<span class="n">vec</span> <span class="p">=</span>  <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span>
			<span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">-</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span>
			<span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">+</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>


<span class="p">}</span></code></pre></figure>

<p>Podemos então usar a função da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="n">Vector2</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">angulo</span> <span class="p">=</span> <span class="m">3.14159f</span><span class="p">;</span>
	
 	<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
 	<span class="p">{</span>
 		<span class="n">v</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
 		<span class="n">v</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">angulo</span><span class="p">);</span>	<span class="c1">// o primeiro argumento da função é o próprio vetor, não é necessário especificá-lo</span>
 		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
 		<span class="c1">// =&gt; (-1, 0)</span>
 	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.]]></summary></entry><entry><title type="html">Raycasts</title><link href="http://localhost:4000/CoralQuest/2024/09/01/Raycasts.html" rel="alternate" type="text/html" title="Raycasts" /><published>2024-09-01T12:00:00-03:00</published><updated>2024-09-01T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/01/Raycasts</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/01/Raycasts.html"><![CDATA[<p>Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.</p>

<p>Exemplos de uso de Raycast:</p>
<ul>
  <li>Determinar se um inimigo consegue ver o jogador quando há obstáculos no caminho</li>
  <li>Saber se o jogador está olhando para um objeto interajível</li>
  <li>Simular tiros de armas quando não queremos usar projéteis</li>
  <li>Calcular o quão longe o jogador está do chão</li>
</ul>

<p>O último pode ser feito da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">LayerMask</span> <span class="n">chaoMask</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">distanciaChao</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">chaoMask</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">GetMask</span><span class="p">(</span><span class="s">"Chao"</span><span class="p">);</span>
	<span class="c1">// Define uma máscara para a camada chão</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">hit</span> <span class="p">=</span> <span class="n">Physics2D</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">down</span><span class="p">,</span> <span class="m">100.0f</span><span class="p">,</span> <span class="n">chaoMask</span><span class="p">)</span>
	<span class="c1">// Faz um Raycast da posição do jogador para baixo, com uma distância máxima de 100 unidades, que só pode colidir com objetos na camada Chao</span>
	<span class="c1">// a variável hit guarda as informações da primeira colisão desse raycast</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">hit</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// se o raycast recordou uma colisão, pegamos sua distância</span>
	<span class="p">{</span>
		<span class="n">distanciaChao</span> <span class="p">=</span> <span class="n">hit</span><span class="p">.</span><span class="n">distance</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">distanciaChao</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.]]></summary></entry><entry><title type="html">Update(), FixedUpdate() e deltaTime</title><link href="http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate.html" rel="alternate" type="text/html" title="Update(), FixedUpdate() e deltaTime" /><published>2024-08-31T12:00:00-03:00</published><updated>2024-08-31T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate.html"><![CDATA[<p>Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.</p>

<p>Para solucionar isso existem duas formas: uso de deltaTime e FixedUpdate().</p>

<h2 id="deltatime">deltaTime</h2>

<p>Time.deltaTime é uma variável do Unity que guarda o tempo em segundos que o computador demorou para calcular o último frame. Podemos utilizar esse valor para padronizar o movimento de objetos.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>O Script acima move o objeto para a direita todo frame. Ao multiplicar a distância movida por deltaTime, garantimos que ela será proporcional a taxa de quadros e igual em qualquer computador</p>

<p>OBS: NEM SEMPRE O USO DE DELTATIME É TÃO SÍMPLES, E O EXEMPLO ACIMA SÓ SE APLICA À MOVIMENTO LINEAR (sem aceleração). <a href="https://www.youtube.com/watch?v=yGhfUcPjXuE&amp;t=205s&amp;pp=ygUJZGVsdGFUaW1l">CLIQUE AQUI</a> PARA MAIS DETALHES SOBRE USO DE DELTATIME</p>

<p>Geralmente, utilizar deltaTime é a forma mais versátil de garantir consistência no comportamento de seu jogo, porém pode ser complicado em algumas situações.</p>

<h2 id="fixedupdate">FixedUpdate()</h2>

<p>FixedUpdate(), por outro lado, ocorre exatamente 60 vezes por segundo(configurável), por isso sempre é consistente entre máquinas*. Apesar disso, Time.fixedDeltaTime está disponível caso necessário.</p>

<p>* Contanto que o computador seja capaz de calcular 60 quadros por segundo. Se esse não for o caso, Update() deve ser utilizado</p>

<p>FixedUpdate() também tem outra característica importante: todo o cálculo de física em Unity (colisões, RigidBody, etc.) é feito nele, então é uma boa ideia colocar partes do código que interajam com a física dentro de FixedUpdate().</p>

<p>Dado isso, existe uma parte do código que é recomendada sempre estar em Update(): Input do usuário.</p>

<p>Um exemplo de movimento horizontal usando Update() e FixedUpdate():</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">RigidBody2D</span> <span class="n">myRB</span><span class="p">;</span>
<span class="n">Float</span> <span class="n">InputX</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">myRB</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RigidBody2D</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">InputX</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
	<span class="c1">// Esse valor varia entre -1 (esquerda), 0 (parado) e 1(direita)</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">myRB</span><span class="p">.</span><span class="n">velocity</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">InputX</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.]]></summary></entry><entry><title type="html">GetComponent()</title><link href="http://localhost:4000/CoralQuest/2024/08/30/GetComponent.html" rel="alternate" type="text/html" title="GetComponent()" /><published>2024-08-30T12:00:00-03:00</published><updated>2024-08-30T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/08/30/GetComponent</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/08/30/GetComponent.html"><![CDATA[<p>Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?</p>

<p>Para fazer isso, utilizamos a função GetComponent(). Dada uma referência ao GameObject do qual queremos pegar um componente, podemos usar:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">RigidBody2D</span> <span class="n">otherRigidBody</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
 <span class="n">otherRigidBody</span> <span class="p">=</span> <span class="n">otherGameObject</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RigidBody2D</span><span class="p">&gt;();</span>
<span class="p">}</span></code></pre></figure>

<p>Existem várias formas de conseguir a referência ao GameObject, algumas são:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">otherGameObject</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"nome objeto"</span><span class="p">);</span>
<span class="c1">// encontra um objeto a partir do nome</span>

<span class="n">childGameObject</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"nome pai/nome filho"</span><span class="p">);</span>
<span class="c1">// encontra um objeto dentro de uma hierarquia</span>

<span class="n">taggedObject</span> <span class="p">=</span> <span class="n">GameObject</span><span class="p">.</span><span class="nf">FindWithTag</span><span class="p">(</span><span class="s">"nome tag"</span><span class="p">);</span>
<span class="c1">// encontra um objeto com uma determinada tag</span>

<span class="n">firstChild</span> <span class="p">=</span> <span class="n">Parent</span><span class="p">.</span><span class="n">transform</span><span class="p">.</span><span class="nf">GetChild</span><span class="p">(</span><span class="m">0</span><span class="p">).</span><span class="n">gameObject</span><span class="p">;</span>
<span class="c1">// Pega o primeiro filho de um objeto conhecido (travessia pela hierarquia geralmente é feita pelo Transform, não GameObject)</span></code></pre></figure>

<p>Como todos os objetos em Unity possuem GameObject e Transform, estes podem ser adquiridos usando “.transform” ou “.gameObject” a partir de qualquer componente</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?]]></summary></entry></feed>