<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:4000/CoralQuest/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/CoralQuest/" rel="alternate" type="text/html" /><updated>2024-10-24T22:37:18-03:00</updated><id>http://localhost:4000/CoralQuest/feed.xml</id><title type="html">Coral Quest</title><subtitle>Coral quest é um jogo desenvolvido por alunos de Engenharia de Software da UnB-FGA como um passo intermediário para desenvolvimento de jogos em Unity a partir do aprendizado dos básicos da engine</subtitle><entry><title type="html">Sprite Sheets e Animação por Sprites</title><link href="http://localhost:4000/CoralQuest/2024/09/09/SpriteSheets.html" rel="alternate" type="text/html" title="Sprite Sheets e Animação por Sprites" /><published>2024-09-09T12:00:00-03:00</published><updated>2024-09-09T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/09/SpriteSheets</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/09/SpriteSheets.html"><![CDATA[<p>Uma Sprite Sheet é, simplesmete, um conjunto de sprites em um só arquivo</p>

<p><img src="../../../img/player_idle-Sheet.png" alt="Player Idle" /></p>

<p>Utilizar spritesheets nos ajuda a manter os arquivos do projeto mais organizados, e facilita na hora de importar animações e tilemaps.</p>

<p>Vamos implementar a animação de idle da jogadora! Primeiro importe a imagem acima ao seu projeto e a configure da seguinte forma:</p>

<p><img src="../../../img/importingss.png" alt="configuração sheet" /></p>

<p>O que define que estamos usando uma sprite sheet é que selecionamos o Sprite Mode “Multiple”. Note que caso queira usar uma imagem que não é pixel art, não é necessário mudar o filter mode ou a forma de compressão.</p>

<p>Para definir onde ficam as divisões entre os sprites, clique em Sprite Editor, em seguida em Slice &gt; Grid by Cell Count(ou cell size, se preferir), defina o número de linhas e colunas (ou o tamanho delas)
, clique em slice e então apply no canto superior direito.</p>

<p><img src="../../../img/slicing.png" alt="Usando o Sprite Editor" /></p>

<p>E pronto, os sprites individuais podem ser vistos ao clicar na setinha na sprite sheet no projeto!</p>

<p><img src="../../../img/slicedsprite.png" alt="Sprite no projeto" /></p>

<h1 id="animações-por-sprites">Animações por sprites</h1>

<p>Para transformar sprites em animação, primeiro abra a janela de animação em Window &gt; Animation &gt; Animation (ou aperte ctrl + 6). Com a janela aberta, Selecione o objeto ao qual deseja adicionar animações e clique Create. Uma janela vai aparecer para que você crie um arquivo de animação, dê o nome de idle.anim (ou o que quiser!).</p>

<p>Arraste os sprites da animação à timeline, duplicando o ultimo frame. Você pode então definir a velocidade desejada aumentando a distancia entre os frames (lembre que por padrão há 60 frames em um segundo).</p>

<p><img src="../../../img/addingssanimation.gif" alt="Animação" /></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Uma Sprite Sheet é, simplesmete, um conjunto de sprites em um só arquivo]]></summary></entry><entry><title type="html">Tilemaps</title><link href="http://localhost:4000/CoralQuest/2024/09/08/Tilemaps.html" rel="alternate" type="text/html" title="Tilemaps" /><published>2024-09-08T12:00:00-03:00</published><updated>2024-09-08T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/08/Tilemaps</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/08/Tilemaps.html"><![CDATA[<p>Tilemaps fornecem uma forma muito mais símples de criar mapas para jogos, permite que os “bloquinhos” que compõe os níveis sejam agrupados por suas propriedades, ao invés de cada um ser um GameObject próprio, também permitindo que sejam posicionados de maneira mais precisa em uma grade.</p>

<p>Para começar a usar tilemaps, primeiro precisamos de alguns sprites. Adicione os sprites que quiser ao seu projeto ou utilize esses:</p>

<p><img src="../../../img/sand_block.png" alt="Areia Topo" /></p>

<p><img src="../../../img/sand_block_below.png" alt="Areia" /></p>

<p><img src="../../../img/walk_rock_block.png" alt="Pedra Topo" /></p>

<p><img src="../../../img/rock_block.png" alt="Pedra" /></p>

<p>Importe as imagens ao seu projeto no Unity, e configure o campo pixel per unit (quantos pixeis do bloco encaixam em uma unidade de comprimento da engine Unity, geralmente igual ao comprimento do lado da imagem):</p>

<p><img src="../../../img/imgcfg.png" alt="Configuração de images" /></p>

<p>*Note que como os sprites do Coral Quest são pixel art, trocamos o filter mode para “point” e a compressão para “none”, você não precisa fazer isso com imagens maiores</p>

<p>Em seguida, no projeto, crie uma Tile Palette com Create &gt; 2D &gt; Tile Palette &gt; Rectangular, não é necessário mudar as opções padrões.</p>

<p>Em Window &gt; 2D &gt; Tile Palette, abra a janela de tile palette</p>

<p><img src="../../../img/tilepalette.png" alt="Janela Tile Palette" /></p>

<p>Para criar suas tiles, arraste as imagens à tile palette, posicionando elas onde desejar.</p>

<p><img src="../../../img/tilesinpalette.png" alt="Tiles na Palette" /></p>

<p>Na hierarquia, crie um tilemap em 2D Object &gt; Tilemap &gt; Rectangular</p>

<p>Selecione o tilemap criado na palette, agora você ja pode desenhar seus níveis!</p>

<p><img src="../../../img/usingpalette.gif" alt="Usando Tilemap" /></p>

<p>Alguns controles úteis:</p>
<ul>
  <li>B para usar o pincel</li>
  <li>Segure shift para apagar</li>
  <li>Segure ctrl para copiar o objeto que clicar (clique e arraste para selecionar varias tiles de uma só vez)</li>
</ul>

<p>ps.: Para adicionar colisão ao seu tilemap, adicione o componente Tilemap Collider 2D.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Tilemaps fornecem uma forma muito mais símples de criar mapas para jogos, permite que os “bloquinhos” que compõe os níveis sejam agrupados por suas propriedades, ao invés de cada um ser um GameObject próprio, também permitindo que sejam posicionados de maneira mais precisa em uma grade.]]></summary></entry><entry><title type="html">Multiplas Câmeras</title><link href="http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras.html" rel="alternate" type="text/html" title="Multiplas Câmeras" /><published>2024-09-07T12:00:00-03:00</published><updated>2024-09-07T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/07/MultipleCameras.html"><![CDATA[<p>Existem várias formas de utilizar várias câmeras simultaneamente no Unity.</p>

<p>Coral Quest utiliza uma câmera principal que vê o nível, e uma câmera de background que somente vê o plano de fundo.</p>

<p>Para alcançar esse efeito, posicione sua tela de fundo em algum lugar em sua cena com uma câmera apontando para ela (garanta que a câmera não possua a tag ‘Main Camera’)</p>

<p><img src="../../../img/telacam.png" alt="Camera e tela de fundo em cena" /></p>

<p>Em seguida, crie um Render Texture na aba de projeto, e o configure com as dimensões desejadas</p>

<p><img src="../../../img/rendertexture.png" alt="Propriedades Render Texture" /></p>

<p>Passe a render texture criada como textura de output da camera</p>

<p><img src="../../../img/outputtexture.png" alt="Atribuição output texture" /></p>

<p>Crie um canvas como objeto filho da câmera principal, e defina o modo de renderização como Screen Space - Camera</p>

<p><img src="../../../img/cameracanvas.png" alt="Canvas filho" /></p>

<p>Crie uma Raw Image como filha do canvas em UI &gt; Raw Image e utilize a render texture como textura</p>

<p><img src="../../../img/texturecanvas.png" alt="Textura no Canvas" /></p>

<p>Por fim, defina a ancoração da imagem para stretch em ambas as direções, segurando alt para copiar a posição</p>

<p><img src="../../../img/anchorpresets.png" alt="Anchor Presets" /></p>

<p>Veja também outras formas de utilizar múltiplas câmeras:</p>

<p><a href="https://www.youtube.com/watch?v=4A-ptevH6-w">https://www.youtube.com/watch?v=4A-ptevH6-w</a></p>

<p><a href="https://www.youtube.com/watch?v=bbnVpPiQ_rU">https://www.youtube.com/watch?v=bbnVpPiQ_rU</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Existem várias formas de utilizar várias câmeras simultaneamente no Unity.]]></summary></entry><entry><title type="html">Interfaces</title><link href="http://localhost:4000/CoralQuest/2024/09/06/Interfaces.html" rel="alternate" type="text/html" title="Interfaces" /><published>2024-09-06T12:00:00-03:00</published><updated>2024-09-06T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/06/Interfaces</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/06/Interfaces.html"><![CDATA[<p>Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.</p>

<p>Pegue por exemplo, Um ataque do jogador que pode atingir inimigos e objetos quebráveis, podemos implementá-lo da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">interface</span> <span class="nc">IDamageable</span>
<span class="p">{</span>
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>No script do ataque</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">OnTriggerEnter2D</span><span class="p">(</span><span class="n">Collider2D</span> <span class="n">collision</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">hit</span> <span class="p">=</span> <span class="n">collision</span><span class="p">.</span><span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">IDamageable</span><span class="p">&gt;()</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hit</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">hit</span><span class="p">.</span><span class="nf">Damage</span><span class="p">(</span><span class="n">dano</span><span class="p">);</span> 
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>No script do inimigo</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Enemy</span><span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">IDamageable</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">health</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
	<span class="cm">/* Implementação da classe
	.
	.
	.
	*/</span>
	
	
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">health</span> <span class="p">-=</span> <span class="n">amount</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>No script do objeto quebrável</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">Crate</span><span class="p">:</span> <span class="n">MonoBehaviour</span><span class="p">,</span> <span class="n">IDamageable</span>
<span class="p">{</span>
	<span class="cm">/* Implementação da classe
	.
	.
	.
	*/</span>
	
	<span class="k">void</span> <span class="nf">BreakObject</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="nf">Destroy</span><span class="p">(</span><span class="n">gameObject</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">void</span> <span class="nf">Damage</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="nf">BreakObject</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.]]></summary></entry><entry><title type="html">Corotinas</title><link href="http://localhost:4000/CoralQuest/2024/09/05/Corotinas.html" rel="alternate" type="text/html" title="Corotinas" /><published>2024-09-05T12:00:00-03:00</published><updated>2024-09-05T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/05/Corotinas</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/05/Corotinas.html"><![CDATA[<p>Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.</p>

<p>Corotinas são declaradas como funçãos com tipo IEnumerator e devem ser chamadas com a função StartCoroutine().</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="k">if</span><span class="p">(</span><span class="n">Input</span><span class="p">.</span><span class="nf">GetKeyDown</span><span class="p">(</span><span class="n">KeyCode</span><span class="p">.</span><span class="n">Space</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">DashForward</span><span class="p">(</span><span class="m">10</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">IEnumerator</span> <span class="nf">DashForward</span><span class="p">(</span><span class="kt">int</span> <span class="n">duracao</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
	Força o jogador a se mover rapidamente para a direita por alguns frames
*/</span>
	<span class="n">mRigidBody</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RigidBody2D</span><span class="p">&gt;();</span>
	
	<span class="k">while</span><span class="p">(</span><span class="n">duracao</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
	<span class="p">{</span>	
		<span class="n">mRigidBody</span><span class="p">.</span><span class="n">velocity</span> <span class="p">=</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="m">5</span><span class="p">;</span>
		<span class="n">duracao</span><span class="p">--;</span>
		<span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Dentro de uma corotina, devemos usar a palavra ´yield´ para indicar onde a execução será pausada até o próximo frame. Podemos também utilizar outros valores no lugar de null, entre eles: ´yield return new WaitForFixedUpdate()´ retomará a execução no proximo frame de fixed update, ‘yield return new WaitForSeconds(3)’ retomará após 3 segundos.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.]]></summary></entry><entry><title type="html">Cenas Aditivas</title><link href="http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas.html" rel="alternate" type="text/html" title="Cenas Aditivas" /><published>2024-09-04T12:00:00-03:00</published><updated>2024-09-04T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/04/CenasAditivas.html"><![CDATA[<p>A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.</p>

<p>Uma forma mais versátil de fazer nossa UI é colocá-la numa cena própria, e então carregar tal cena de forma aditiva(ou, por cima) da cena da fase.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="nf">StartCoroutine</span><span class="p">(</span><span class="nf">LoadUI</span><span class="p">());</span>
<span class="p">}</span>
<span class="n">IEnumerator</span> <span class="nf">LoadUI</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">_UIScene</span> <span class="p">=</span> <span class="n">SceneManager</span><span class="p">.</span><span class="nf">LoadScene</span><span class="p">(</span><span class="s">"UI"</span><span class="p">,</span> <span class="k">new</span> <span class="nf">LoadSceneParameters</span><span class="p">(</span><span class="n">LoadSceneMode</span><span class="p">.</span><span class="n">Additive</span><span class="p">));</span>   <span class="c1">// Carrega a UI por cima da cena inicial</span>

        <span class="k">while</span><span class="p">(!</span><span class="n">_UIScene</span><span class="p">.</span><span class="n">isLoaded</span><span class="p">)</span>   <span class="c1">// Espera até a UI estar carregada</span>
        <span class="p">{</span>
            <span class="k">yield</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Note que carregar cenas aditivamente pode demorar um pouco, por isso é recomendado usar uma <a href="../../../2024/09/05/Corotinas.html">Corotina</a></p>

<p>A desvantagem desse método é que referências entre objetos da UI e da fase devem ser tratadas com mais atenção. Utilizar o <a href="../../../2024/09/03/Singleton.html">Padrão Singleton</a>, e tags pode ajudar bastante. Outra forma é utilizar a referência a cena retornada pela função LoadScene().</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">_UIScene</span><span class="p">.</span><span class="nf">GetRootGameObjects</span><span class="p">()[</span><span class="m">0</span><span class="p">].</span><span class="n">transform</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="s">"Health Bar"</span><span class="p">).</span><span class="nf">SetFullHP</span><span class="p">();</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.]]></summary></entry><entry><title type="html">Padrão Singleton</title><link href="http://localhost:4000/CoralQuest/2024/09/03/Singleton.html" rel="alternate" type="text/html" title="Padrão Singleton" /><published>2024-09-03T12:00:00-03:00</published><updated>2024-09-03T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/03/Singleton</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/03/Singleton.html"><![CDATA[<p>Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.</p>

<p>O GameManager possui uma característica que pode nos ajudar a referênciá-lo de forma eficiente, isto é o fato que só pode existir um destes objetos ativos em um dado momento. Isso nos possibilita o uso do padrão Singleton de design.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">GameManager</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="c1">//</span>
	<span class="c1">//    ...</span>
	<span class="c1">//</span>
	<span class="k">public</span> <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
	<span class="k">public</span> <span class="k">static</span> <span class="n">GameManager</span> <span class="n">Instance</span><span class="p">;</span>
	
	<span class="k">void</span> <span class="nf">Awake</span><span class="p">()</span>	<span class="c1">// Awake ocorre ainda antes do Start()</span>
	<span class="p">{</span>
		<span class="n">Instance</span> <span class="p">=</span> <span class="k">this</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="c1">//</span>
	<span class="c1">//    ...</span>
	<span class="c1">//</span>

<span class="p">}</span></code></pre></figure>

<p>Referências ao GameManager podem então ser feitas assim:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">GameManager</span><span class="p">.</span><span class="n">Instance</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
		<span class="c1">// =&gt; 3</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p><a href="https://gamedevbeginner.com/singletons-in-unity-the-right-way/">Mais sobre o padrão Singleton</a></p>]]></content><author><name></name></author><summary type="html"><![CDATA[Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.]]></summary></entry><entry><title type="html">Helper Classes &amp;amp; Extension Methods</title><link href="http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao.html" rel="alternate" type="text/html" title="Helper Classes &amp;amp; Extension Methods" /><published>2024-09-02T12:00:00-03:00</published><updated>2024-09-02T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/02/MetodosExtensao.html"><![CDATA[<p>Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.</p>

<p>Uma helper Class é uma classe estática (pode ser chamada de qualquer parte do código) que guarda esse tipo de função que é útil em vários cenários.</p>

<p>O Código a seguir implementa uma helper class com uma função que eleva um número ao quadrado e o divide por 3</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Helpers</span> <span class="c1">// note que essa classe não herda de MonoBehaviour</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">static</span> <span class="kt">float</span> <span class="nf">SquareAndCut3</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">x</span> <span class="p">*</span> <span class="n">x</span> <span class="p">/</span> <span class="m">3</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Essa função pode então ser utilizada em outras classes:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
	<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">Helpers</span><span class="p">.</span><span class="nf">SquareAndCut3</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
		<span class="n">a</span><span class="p">++;</span>
		<span class="c1">// Imprime ao console o resultado da equação todo frame e incrementa o valor de entrada</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Uma ideia similar à de Helper Classes é Extension Classes.</p>

<p>Nós não temos acesso ao código das classes já presentes no Unity (ex.: Transform, AudioSource, Vector3), porém existem situações em que seria conveniente adicionar uma função à uma dessas classes.</p>

<p>Por exemplo, você pode achar que caso queira rotacionar um Vector2 em um ângulo específico, deve existir uma função Vector2.Rotate(angulo), porém essa função não existe.
Uma solução para isso seria implementar uma função RotateVector2() numa helper class, porém há uma solução mais elegante utilizando uma classe de extenção.:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ExtensionMethods</span>
<span class="p">{</span>

	<span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Rotate</span><span class="p">(</span><span class="k">this</span> <span class="n">Vector2</span> <span class="n">vec</span><span class="p">,</span> <span class="kt">float</span> <span class="n">delta</span><span class="p">)</span> 	<span class="c1">// O termo 'this' no primeiro argumento define que isso é uma extensão da classe Vector2</span>
	<span class="p">{</span>
		<span class="n">vec</span> <span class="p">=</span>  <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span>
			<span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">-</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">delta</span><span class="p">),</span>
			<span class="n">vec</span><span class="p">.</span><span class="n">x</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Sin</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span> <span class="p">+</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span> <span class="p">*</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">Cos</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
		<span class="p">);</span>
	<span class="p">}</span>


<span class="p">}</span></code></pre></figure>

<p>Podemos então usar a função da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">public</span> <span class="k">class</span> <span class="nc">MinhaClasse</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
	<span class="n">Vector2</span> <span class="n">v</span><span class="p">;</span>
	<span class="kt">float</span> <span class="n">angulo</span> <span class="p">=</span> <span class="m">3.14159f</span><span class="p">;</span>
	
 	<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
 	<span class="p">{</span>
 		<span class="n">v</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
 		<span class="n">v</span><span class="p">.</span><span class="nf">Rotate</span><span class="p">(</span><span class="n">angulo</span><span class="p">);</span>	<span class="c1">// o primeiro argumento da função é o próprio vetor, não é necessário especificá-lo</span>
 		<span class="n">Debug</span><span class="p">.</span><span class="nf">Log</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
 		<span class="c1">// =&gt; (-1, 0)</span>
 	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.]]></summary></entry><entry><title type="html">Raycasts</title><link href="http://localhost:4000/CoralQuest/2024/09/01/Raycasts.html" rel="alternate" type="text/html" title="Raycasts" /><published>2024-09-01T12:00:00-03:00</published><updated>2024-09-01T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/09/01/Raycasts</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/09/01/Raycasts.html"><![CDATA[<p>Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.</p>

<p>Exemplos de uso de Raycast:</p>
<ul>
  <li>Determinar se um inimigo consegue ver o jogador quando há obstáculos no caminho</li>
  <li>Saber se o jogador está olhando para um objeto interajível</li>
  <li>Simular tiros de armas quando não queremos usar projéteis</li>
  <li>Calcular o quão longe o jogador está do chão</li>
</ul>

<p>O último pode ser feito da seguinte forma:</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">LayerMask</span> <span class="n">chaoMask</span><span class="p">;</span>
<span class="kt">float</span> <span class="n">distanciaChao</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">chaoMask</span> <span class="p">=</span> <span class="n">LayerMask</span><span class="p">.</span><span class="nf">GetMask</span><span class="p">(</span><span class="s">"Chao"</span><span class="p">);</span>
	<span class="c1">// Define uma máscara para a camada chão</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="kt">var</span> <span class="n">hit</span> <span class="p">=</span> <span class="n">Physics2D</span><span class="p">.</span><span class="nf">Raycast</span><span class="p">(</span><span class="n">transform</span><span class="p">.</span><span class="n">position</span><span class="p">,</span> <span class="n">Vector2</span><span class="p">.</span><span class="n">down</span><span class="p">,</span> <span class="m">100.0f</span><span class="p">,</span> <span class="n">chaoMask</span><span class="p">)</span>
	<span class="c1">// Faz um Raycast da posição do jogador para baixo, com uma distância máxima de 100 unidades, que só pode colidir com objetos na camada Chao</span>
	<span class="c1">// a variável hit guarda as informações da primeira colisão desse raycast</span>
	
	<span class="k">if</span><span class="p">(</span><span class="n">hit</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="c1">// se o raycast recordou uma colisão, pegamos sua distância</span>
	<span class="p">{</span>
		<span class="n">distanciaChao</span> <span class="p">=</span> <span class="n">hit</span><span class="p">.</span><span class="n">distance</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="n">distanciaChao</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.]]></summary></entry><entry><title type="html">Update(), FixedUpdate() e deltaTime</title><link href="http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate.html" rel="alternate" type="text/html" title="Update(), FixedUpdate() e deltaTime" /><published>2024-08-31T12:00:00-03:00</published><updated>2024-08-31T12:00:00-03:00</updated><id>http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate</id><content type="html" xml:base="http://localhost:4000/CoralQuest/2024/08/31/Update-FixedUpdate.html"><![CDATA[<p>Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.</p>

<p>Para solucionar isso existem duas formas: uso de deltaTime e FixedUpdate().</p>

<h2 id="deltatime">deltaTime</h2>

<p>Time.deltaTime é uma variável do Unity que guarda o tempo em segundos que o computador demorou para calcular o último frame. Podemos utilizar esse valor para padronizar o movimento de objetos.</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">transform</span><span class="p">.</span><span class="n">position</span> <span class="p">+=</span> <span class="n">Vector3</span><span class="p">.</span><span class="n">right</span> <span class="p">*</span> <span class="n">Time</span><span class="p">.</span><span class="n">deltaTime</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>O Script acima move o objeto para a direita todo frame. Ao multiplicar a distância movida por deltaTime, garantimos que ela será proporcional a taxa de quadros e igual em qualquer computador</p>

<p>OBS: NEM SEMPRE O USO DE DELTATIME É TÃO SÍMPLES, E O EXEMPLO ACIMA SÓ SE APLICA À MOVIMENTO LINEAR (sem aceleração). <a href="https://www.youtube.com/watch?v=yGhfUcPjXuE&amp;t=205s&amp;pp=ygUJZGVsdGFUaW1l">CLIQUE AQUI</a> PARA MAIS DETALHES SOBRE USO DE DELTATIME</p>

<p>Geralmente, utilizar deltaTime é a forma mais versátil de garantir consistência no comportamento de seu jogo, porém pode ser complicado em algumas situações.</p>

<h2 id="fixedupdate">FixedUpdate()</h2>

<p>FixedUpdate(), por outro lado, ocorre exatamente 60 vezes por segundo(configurável), por isso sempre é consistente entre máquinas*. Apesar disso, Time.fixedDeltaTime está disponível caso necessário.</p>

<p>* Contanto que o computador seja capaz de calcular 60 quadros por segundo. Se esse não for o caso, Update() deve ser utilizado</p>

<p>FixedUpdate() também tem outra característica importante: todo o cálculo de física em Unity (colisões, RigidBody, etc.) é feito nele, então é uma boa ideia colocar partes do código que interajam com a física dentro de FixedUpdate().</p>

<p>Dado isso, existe uma parte do código que é recomendada sempre estar em Update(): Input do usuário.</p>

<p>Um exemplo de movimento horizontal usando Update() e FixedUpdate():</p>

<figure class="highlight"><pre><code class="language-c#" data-lang="c#"><span class="n">RigidBody2D</span> <span class="n">myRB</span><span class="p">;</span>
<span class="n">Float</span> <span class="n">InputX</span><span class="p">;</span>

<span class="k">void</span> <span class="nf">Start</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">myRB</span> <span class="p">=</span> <span class="n">GetComponent</span><span class="p">&lt;</span><span class="n">RigidBody2D</span><span class="p">&gt;();</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">Update</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">InputX</span> <span class="p">=</span> <span class="n">Input</span><span class="p">.</span><span class="nf">GetAxis</span><span class="p">(</span><span class="s">"Horizontal"</span><span class="p">);</span>
	<span class="c1">// Esse valor varia entre -1 (esquerda), 0 (parado) e 1(direita)</span>
<span class="p">}</span>

<span class="k">void</span> <span class="nf">FixedUpdate</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">myRB</span><span class="p">.</span><span class="n">velocity</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Vector2</span><span class="p">(</span><span class="n">InputX</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>]]></content><author><name></name></author><summary type="html"><![CDATA[Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.]]></summary></entry></feed>