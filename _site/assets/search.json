

[
  
  
    
    
      {
        "title": "GetComponent()",
        "excerpt": "Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?\n",
        "content": "Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?\n\nPara fazer isso, utilizamos a função GetComponent(). Dada uma referência ao GameObject do qual queremos pegar um componente, podemos usar:\n\nRigidBody2D otherRigidBody;\n\nvoid Start()\n{\n otherRigidBody = otherGameObject.GetComponent&lt;RigidBody2D&gt;();\n}\n\nExistem várias formas de conseguir a referência ao GameObject, algumas são:\n\notherGameObject = GameObject.Find(\"nome objeto\");\n// encontra um objeto a partir do nome\n\nchildGameObject = GameObject.Find(\"nome pai/nome filho\");\n// encontra um objeto dentro de uma hierarquia\n\ntaggedObject = GameObject.FindWithTag(\"nome tag\");\n// encontra um objeto com uma determinada tag\n\nfirstChild = Parent.transform.GetChild(0).gameObject;\n// Pega o primeiro filho de um objeto conhecido (travessia pela hierarquia geralmente é feita pelo Transform, não GameObject)\n\nComo todos os objetos em Unity possuem GameObject e Transform, estes podem ser adquiridos usando “.transform” ou “.gameObject” a partir de qualquer componente\n",
        "url": "/CoralQuest/2024/08/30/GetComponent.html"
      },
    
      {
        "title": "Update(), FixedUpdate() e deltaTime",
        "excerpt": "Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.\n",
        "content": "Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.\n\nPara solucionar isso existem duas formas: uso de deltaTime e FixedUpdate().\n\ndeltaTime\n\nTime.deltaTime é uma variável do Unity que guarda o tempo em segundos que o computador demorou para calcular o último frame. Podemos utilizar esse valor para padronizar o movimento de objetos.\n\nvoid Update()\n{\n\ttransform.position += Vector3.right * Time.deltaTime;\n}\n\nO Script acima move o objeto para a direita todo frame. Ao multiplicar a distância movida por deltaTime, garantimos que ela será proporcional a taxa de quadros e igual em qualquer computador\n\nOBS: NEM SEMPRE O USO DE DELTATIME É TÃO SÍMPLES, E O EXEMPLO ACIMA SÓ SE APLICA À MOVIMENTO LINEAR (sem aceleração). CLIQUE AQUI PARA MAIS DETALHES SOBRE USO DE DELTATIME\n\nGeralmente, utilizar deltaTime é a forma mais versátil de garantir consistência no comportamento de seu jogo, porém pode ser complicado em algumas situações.\n\nFixedUpdate()\n\nFixedUpdate(), por outro lado, ocorre exatamente 60 vezes por segundo(configurável), por isso sempre é consistente entre máquinas*. Apesar disso, Time.fixedDeltaTime está disponível caso necessário.\n\n* Contanto que o computador seja capaz de calcular 60 quadros por segundo. Se esse não for o caso, Update() deve ser utilizado\n\nFixedUpdate() também tem outra característica importante: todo o cálculo de física em Unity (colisões, RigidBody, etc.) é feito nele, então é uma boa ideia colocar partes do código que interajam com a física dentro de FixedUpdate().\n\nDado isso, existe uma parte do código que é recomendada sempre estar em Update(): Input do usuário.\n\nUm exemplo de movimento horizontal usando Update() e FixedUpdate():\n\nRigidBody2D myRB;\nFloat InputX;\n\nvoid Start()\n{\n\tmyRB = GetComponent&lt;RigidBody2D&gt;();\n}\n\nvoid Update()\n{\n\tInputX = Input.GetAxis(\"Horizontal\");\n\t// Esse valor varia entre -1 (esquerda), 0 (parado) e 1(direita)\n}\n\nvoid FixedUpdate()\n{\n\tmyRB.velocity = new Vector2(InputX, 0);\n}\n\n",
        "url": "/CoralQuest/2024/08/31/Update-FixedUpdate.html"
      },
    
      {
        "title": "Raycasts",
        "excerpt": "Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.\n",
        "content": "Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.\n\nExemplos de uso de Raycast:\n\n  Determinar se um inimigo consegue ver o jogador quando há obstáculos no caminho\n  Saber se o jogador está olhando para um objeto interajível\n  Simular tiros de armas quando não queremos usar projéteis\n  Calcular o quão longe o jogador está do chão\n\n\nO último pode ser feito da seguinte forma:\n\nLayerMask chaoMask;\nfloat distanciaChao;\n\nvoid Start()\n{\n\tchaoMask = LayerMask.GetMask(\"Chao\");\n\t// Define uma máscara para a camada chão\n}\n\nvoid Update()\n{\n\tvar hit = Physics2D.Raycast(transform.position, Vector2.down, 100.0f, chaoMask)\n\t// Faz um Raycast da posição do jogador para baixo, com uma distância máxima de 100 unidades, que só pode colidir com objetos na camada Chao\n\t// a variável hit guarda as informações da primeira colisão desse raycast\n\t\n\tif(hit != null) // se o raycast recordou uma colisão, pegamos sua distância\n\t{\n\t\tdistanciaChao = hit.distance;\n\t}\n\telse\n\t{\n\t\tdistanciaChao = -1;\n\t}\n}\n\n",
        "url": "/CoralQuest/2024/09/01/Raycasts.html"
      },
    
      {
        "title": "Helper Classes & Extension Methods",
        "excerpt": "Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.\n",
        "content": "Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.\n\nUma helper Class é uma classe estática (pode ser chamada de qualquer parte do código) que guarda esse tipo de função que é útil em vários cenários.\n\nO Código a seguir implementa uma helper class com uma função que eleva um número ao quadrado e o divide por 3\n\npublic static class Helpers // note que essa classe não herda de MonoBehaviour\n{\n\tpublic static float SquareAndCut3(float x)\n\t{\n\t\treturn x * x / 3;\n\t}\n}\n\nEssa função pode então ser utilizada em outras classes:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tint a = 0;\n\tvoid Update()\n\t{\n\t\tDebug.Log(Helpers.SquareAndCut3(a));\n\t\ta++;\n\t\t// Imprime ao console o resultado da equação todo frame e incrementa o valor de entrada\n\t}\n}\n\nUma ideia similar à de Helper Classes é Extension Classes.\n\nNós não temos acesso ao código das classes já presentes no Unity (ex.: Transform, AudioSource, Vector3), porém existem situações em que seria conveniente adicionar uma função à uma dessas classes.\n\nPor exemplo, você pode achar que caso queira rotacionar um Vector2 em um ângulo específico, deve existir uma função Vector2.Rotate(angulo), porém essa função não existe.\nUma solução para isso seria implementar uma função RotateVector2() numa helper class, porém há uma solução mais elegante utilizando uma classe de extenção.:\n\npublic static class ExtensionMethods\n{\n\n\tpublic static void Rotate(this Vector2 vec, float delta) \t// O termo 'this' no primeiro argumento define que isso é uma extensão da classe Vector2\n\t{\n\t\tvec =  new Vector2(\n\t\t\tvec.x * Mathf.Cos(delta) - vec.y * Mathf.Sin(delta),\n\t\t\tvec.x * Mathf.Sin(delta) + vec.y * Mathf.Cos(delta)\n\t\t);\n\t}\n\n\n}\n\nPodemos então usar a função da seguinte forma:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tVector2 v;\n\tfloat angulo = 3.14159f;\n\t\n \tvoid Start()\n \t{\n \t\tv = new Vector2(1, 0);\n \t\tv.Rotate(angulo);\t// o primeiro argumento da função é o próprio vetor, não é necessário especificá-lo\n \t\tDebug.Log(v);\n \t\t// =&gt; (-1, 0)\n \t}\n}\n\n",
        "url": "/CoralQuest/2024/09/02/MetodosExtensao.html"
      },
    
      {
        "title": "Padrão Singleton",
        "excerpt": "Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.\n",
        "content": "Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.\n\nO GameManager possui uma característica que pode nos ajudar a referênciá-lo de forma eficiente, isto é o fato que só pode existir um destes objetos ativos em um dado momento. Isso nos possibilita o uso do padrão Singleton de design.\n\npublic class GameManager : MonoBehaviour\n{\n\t//\n\t//    ...\n\t//\n\tpublic int a = 3;\n\tpublic static GameManager Instance;\n\t\n\tvoid Awake()\t// Awake ocorre ainda antes do Start()\n\t{\n\t\tInstance = this;\n\t}\n\t\n\t//\n\t//    ...\n\t//\n\n}\n\nReferências ao GameManager podem então ser feitas assim:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tvoid Start()\n\t{\n\t\tDebug.Log(GameManager.Instance.a);\n\t\t// =&gt; 3\n\t}\n}\n\nMais sobre o padrão Singleton\n",
        "url": "/CoralQuest/2024/09/03/Singleton.html"
      },
    
      {
        "title": "Cenas Aditivas",
        "excerpt": "A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.\n",
        "content": "A UI é uma parte muito importante de qualquer jogo, mais importante ainda é que ela seja consistente entre fases diferentes. A forma que vimos para criar UIs até agora não é ideal, pois ao fazer alterações, precisamos replicá-las em todas as cenas que a usam.\n\nUma forma mais versátil de fazer nossa UI é colocá-la numa cena própria, e então carregar tal cena de forma aditiva(ou, por cima) da cena da fase.\n\nvoid Start()\n{\n\tStartCoroutine(LoadUI());\n}\nIEnumerator LoadUI()\n{\n\tvar _UIScene = SceneManager.LoadScene(\"UI\", new LoadSceneParameters(LoadSceneMode.Additive));   // Carrega a UI por cima da cena inicial\n\n        while(!_UIScene.isLoaded)   // Espera até a UI estar carregada\n        {\n            yield return null;\n        }\n}\n\nNote que carregar cenas aditivamente pode demorar um pouco, por isso é recomendado usar uma Corotina\n\nA desvantagem desse método é que referências entre objetos da UI e da fase devem ser tratadas com mais atenção. Utilizar o Padrão Singleton, e tags pode ajudar bastante. Outra forma é utilizar a referência a cena retornada pela função LoadScene().\n\n_UIScene.GetRootGameObjects()[0].transform.Find(\"Health Bar\").SetFullHP();\n\n",
        "url": "/CoralQuest/2024/09/04/CenasAditivas.html"
      },
    
      {
        "title": "Corotinas",
        "excerpt": "Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.\n",
        "content": "Uma das ferramentas mais importantes da Unity são as Corotinas, elas permitem dividir o fluxo de execução do script e fazer com que uma função seja executada ao longo de vários frames.\n\nCorotinas são declaradas como funçãos com tipo IEnumerator e devem ser chamadas com a função StartCoroutine().\n\nvoid Update()\n{\n\tif(Input.GetKeyDown(KeyCode.Space))\n\t{\n\t\tStartCoroutine(DashForward(10));\n\t}\n}\n\nIEnumerator DashForward(int duracao)\n{\n/*\n\tForça o jogador a se mover rapidamente para a direita por alguns frames\n*/\n\tmRigidBody = GetComponent&lt;RigidBody2D&gt;();\n\t\n\twhile(duracao &gt; 0)\n\t{\t\n\t\tmRigidBody.velocity = Vector2.right * 5;\n\t\tduracao--;\n\t\tyield return null;\n\t}\n}\n\nDentro de uma corotina, devemos usar a palavra ´yield´ para indicar onde a execução será pausada até o próximo frame. Podemos também utilizar outros valores no lugar de null, entre eles: ´yield return new WaitForFixedUpdate()´ retomará a execução no proximo frame de fixed update, ‘yield return new WaitForSeconds(3)’ retomará após 3 segundos.\n\n",
        "url": "/CoralQuest/2024/09/05/Corotinas.html"
      },
    
      {
        "title": "Interfaces",
        "excerpt": "Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.\n",
        "content": "Uma interface, nesse contexto, não se trata da interface de usuário(UI), mas de uma ferramenta de Orientação à Objetos que nos permite abstrair classes à um conjunto de métodos comuns a todas elas.\n\nPegue por exemplo, Um ataque do jogador que pode atingir inimigos e objetos quebráveis, podemos implementá-lo da seguinte forma:\n\npublic interface IDamageable\n{\n\tvoid Damage(int amount);\n}\n\nNo script do ataque\n\nvoid OnTriggerEnter2D(Collider2D collision)\n{\n\thit = collision.GetComponent&lt;IDamageable&gt;()\n\tif(hit != null)\n\t{\n\t\thit.Damage(dano); \n\t}\n}\n\nNo script do inimigo\n\npublic class Enemy: MonoBehaviour, IDamageable\n{\n\tint health = 100;\n\t/* Implementação da classe\n\t.\n\t.\n\t.\n\t*/\n\t\n\t\n\tvoid Damage(int amount)\n\t{\n\t\thealth -= amount;\n\t}\n}\n\nNo script do objeto quebrável\n\npublic class Crate: MonoBehaviour, IDamageable\n{\n\t/* Implementação da classe\n\t.\n\t.\n\t.\n\t*/\n\t\n\tvoid BreakObject()\n\t{\n\t\tDestroy(gameObject);\n\t}\n\t\n\tvoid Damage(int amount)\n\t{\n\t\tBreakObject();\n\t}\n}\n\n",
        "url": "/CoralQuest/2024/09/06/Interfaces.html"
      },
    
      {
        "title": "Multiplas Câmeras",
        "excerpt": "Existem várias formas de utilizar várias câmeras simultaneamente no Unity.\n",
        "content": "Existem várias formas de utilizar várias câmeras simultaneamente no Unity.\n\nCoral Quest utiliza uma câmera principal que vê o nível, e uma câmera de background que somente vê o plano de fundo.\n\nPara alcançar esse efeito, posicione sua tela de fundo em algum lugar em sua cena com uma câmera apontando para ela (garanta que a câmera não possua a tag ‘Main Camera’)\n\n\n\nEm seguida, crie um Render Texture na aba de projeto, e o configure com as dimensões desejadas\n\n\n\nPasse a render texture criada como textura de output da camera\n\n\n\nCrie um canvas como objeto filho da câmera principal, e defina o modo de renderização como Screen Space - Camera\n\n\n\nCrie uma Raw Image como filha do canvas em UI &gt; Raw Image e utilize a render texture como textura\n\n\n\nPor fim, defina a ancoração da imagem para stretch em ambas as direções, segurando alt para copiar a posição\n\n\n\nVeja também outras formas de utilizar múltiplas câmeras:\n\nhttps://www.youtube.com/watch?v=4A-ptevH6-w\n\nhttps://www.youtube.com/watch?v=bbnVpPiQ_rU\n\n",
        "url": "/CoralQuest/2024/09/07/MultipleCameras.html"
      },
    
  
  
  
  {
    "title": "Créditos",
    "excerpt": "\n",
    "content": "\n  Idealização - Carla Rocha\n\n\nConteúdo original\n\n  Programação - Laís Soares\n  Arte - Wonnz Lopes\n  Música - Herbert Kiragon\n  Efeitos Sonoros - Laís Soares, Wonnz Lopes, Herbert Kiragon\n\n\nAssets livres - Efeitos sonoros\n\n  pixabay\n  jofae\n  Sslc2022\n  LordSonny\n  floraphonic\n  UNIVERSFIELD\n  VoiceBosch\n    Assets livres - Música(menu e cena final)\n  \n  Pix\n\n\nPacotes Unity de terceiros\n\n  Fenerax Studios\n\n",
    "url": "/CoralQuest/creditos/"
  },
  
  {
    "title": "Bem vindo ao Coral Quest site!",
    "excerpt": "\n",
    "content": "O que é Coral Quest?\nCoral Quest é um jogo criado como material de estudo de GameDev em Unity, e foi feito como continuação da Workshop Unity for Women, desenvolvida pela BOSS, a iniciativa da UnB com o objetivo de promover participação de minorias na comunidade Open Source.\n\nComo é o jogo?\nCoral quest é um platformer 2D, feito inteiramente com pixel art, de forma a lembrar jogos retro mais símples, o gameplay foi inspirado pelo gênero de Metroidvania, especialmente Hollow Knight, apesar de não ser muito longo.\n\nO jogo possui:\n\n  2 fases, sendo uma delas uma arena para boss fight\n  5 inimigos únicos\n  150+ Assets de uso livre, feitos por nós que incluem sprites e parte dos audios\n\n\n\n\nQual é a proposta do jogo?\nA partir do conteúdo da Workshop Unity for Women, os alunos encarregados desse projeto criaram um jogo aprofundando os conceitos e ferramentas básicas do Unity, com o objetivo de mostrar o que pode ser feito sem um conhecimento muito profundo da plataforma, enquanto ao mesmo tempo introduzindo novas ferramentas progressivamente.\n\n\n\nEssas ferramentas incluem:\n\n  Raycasts\n  Diferênciação do uso de Update (input) e FixedUpdate(física)\n  Tilemaps\n  Spritesheets para Animação\n  Cenas Aditivas\n  Extension Classes\n  Padrão de Design Singleton\n  Uso de várias câmeras simultâneamente\n  Interfaces(Orientação à Objetos)\n\n\nUnity\nFoi usada a versão 2021.3.43f1 do editor Unity com o template 2D, e essa é a versão recomendada ao rodar o projeto.\n\n\n\nTambém foi utilizado o pacote Universal Render Pipeline(URP).\n\nLicensa\nO Repositório e jogo são disponibilizados sobre a licensa MIT .\n\n",
    "url": "/CoralQuest/"
  },
  
  {
    "title": "Sobre Nós",
    "excerpt": "\n",
    "content": "Laís Soares\nEstudante cursando enegnharia de softaware e programadora do inteiro do jogo, assim como editora dos efeitos sonoros\n\nLopes\nCursando engenharia de software e criadora de todas as sprites e desenhos do jogo, e também criadora e editora dos efeitos sonoros.\n\nHebert Kiragon\nArtista músical e componente da banda Maverick Hunters. Ele compoz a soundtrack principal do jogo\n\n",
    "url": "/CoralQuest/aboutUs/"
  },
  
  {
    "title": "Nossa Experiência",
    "excerpt": "\n",
    "content": "Lopes\nA criação desse jogo foi uma nova experiência na vida, já que é a primeira vez que tive que trabalhar em um projeto sério e não um trabalho designado por uma matéria. O processo de criação dos designs dos personagens foi uma das partes mais divertidas para mim. O tema do jogo desde o começo era aquático, mas eu decidi fazer a primeira versão da protagonista um robô com braços de tentáculo (a única característica da primeira versão que tinha algo a ver com o tema do jogo).\n\n\n\nComo a primeira versão não fez muito sentido, comecei a pesquisar por criatura marinhas até que eu me deparei com, duas criaturas específicas: a primeira foi um lesma do mar, em particular a ovelha-folha, uma lesma capaz de realizar fotossíntese. O novo design da personagem veio quase instantaneamente na minha cabeça e só tive que fazer mínimos reajustes que fossem viáveis de animar para o jogo(o design final acabou não tendo o rabinho).\n\n \n\nA segunda foi a água-viva fantasma gigante, as cores e aparência da criatura é tão bonito que eu quase fiz a protagonista ser uma água-viva, mas decidi permanecer co design da lesma e reutilizar esse design de outra forma.\nO save point eu sabia que eu queria fazer algo envolvendo luz, então a primeira ideia foi uma lâmpada que a versão final virou um coral em formato de sol.\n\n\n\n\n\nDurante o período de produção do jogo, apesar de alguns momentos de dificuldade, fazer as sprites/arte do jogo foi um processo sem muita dificuldade, o problema é que eu queria ter aprendido programação, mas eu decidi fazer a arte ao mesmo tempo, o que no começo parecia atingível. Em poucas semanas, a arte virou o meu foco por completo. A carga da arte que tive que fazer roubou toda minha atenção: adicionando mais blocos, fazendo eles misturarem, mas o pior ponto foi quando descobrimos que a sprite da protagonista estava muito alta para o jogo e tive que refazer ela todinha de novo. Quando chegou nas etapas finais do jogo, eu comecei a editar e criar áudios para os inimigos e protagonista.\nOlhando o agora, com o jogo completo, eu tenho vários arrependimentos, sendo o principal a falta de comunicação com a Carla durante o processo. Por grande parte do tempo em que o jogo evoluía, a maior quantidade de informação que ela recebia era “que o jogo está progredindo”, mas a gente nunca deixava claro o que isso queria dizer ou o quanto faltava, levou messes até ela poder finalmente ver esse progresso de que tanto falávamos. \n  Outra dificuldade foi a autodisciplina. Fazer o jogo funcionar era em sua maioria, uma questão de pesquisar como fazer funcionar, reproduzir, descobrir por que não funcionou e pronto, mais uma parte do jogo era adicionado. Eu tô explicando de forma bem simples, mas o ponto é que mesmo que levasse dias para fazer a feature funcionar era menos uma questão de dificuldade (o que ainda era bem presente) e mais uma de disciplina.\n",
    "url": "/CoralQuest/experience/"
  },
  
  {
    "title": "Tutoriais",
    "excerpt": "\n",
    "content": "Estes tutoriais assumem um conhecimento das ferramentas básicas do Unity, que podem ser vistas em BOSS:Unity for women.\n\n",
    "url": "/CoralQuest/tutoriais/"
  }
  
]

