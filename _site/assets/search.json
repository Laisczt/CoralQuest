

[
  
  
    
    
      {
        "title": "GetComponent()",
        "excerpt": "Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?\n",
        "content": "Quando precisamos que um script interaja com outros componentes em nossos objetos, vimos que é possível referenciá-los declarando uma variável pública e arrastando o componente no editor. Porém nem sempre é possível fazer isso; por exemplo, como você referenciaria o RigidBody2D de um objeto que foi instanciado depois de apertar play?\n\nPara fazer isso, utilizamos a função GetComponent(). Dada uma referência ao GameObject do qual queremos pegar um componente, podemos usar:\n\nRigidBody2D otherRigidBody;\n\nvoid Start()\n{\n otherRigidBody = otherGameObject.GetComponent&lt;RigidBody2D&gt;();\n}\n\nExistem várias formas de conseguir a referência ao GameObject, algumas são:\n\notherGameObject = GameObject.Find(\"nome objeto\");\n// encontra um objeto a partir do nome\n\nchildGameObject = GameObject.Find(\"nome pai/nome filho\");\n// encontra um objeto dentro de uma hierarquia\n\ntaggedObject = GameObject.FindWithTag(\"nome tag\");\n// encontra um objeto com uma determinada tag\n\nfirstChild = Parent.transform.GetChild(0).gameObject;\n// Pega o primeiro filho de um objeto conhecido (travessia pela hierarquia geralmente é feita pelo Transform, não GameObject)\n\nComo todos os objetos em Unity possuem GameObject e Transform, estes podem ser adquiridos usando “.transform” ou “.gameObject” a partir de qualquer componente\n",
        "url": "/CoralQuest/2024/08/30/GetComponent.html"
      },
    
      {
        "title": "Update(), FixedUpdate() e deltaTime",
        "excerpt": "Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.\n",
        "content": "Vimos que a parte principal do código de objetos dinâmicos é feita dentro da função Update(), isto é, esse código rodará todo frame. Mas existe um problema com isso, um frame ocorre sempre que o Unity finaliza a execução de todo o código dentro de todos os Update()’s, o tempo entre frames pode variar à medida que o jogo cresce e, principalmente, a depender do hardware em que o jogo está rodando. Caso você desenvolva seu jogo em um computador que é capaz de rodar o jogo à 120 FPS (frames por segundo), um usuário com um computador que só é capaz de 60 FPS irá experienciar seu jogo em câmera lenta.\n\nPara solucionar isso existem duas formas: uso de deltaTime e FixedUpdate().\n\ndeltaTime\n\nTime.deltaTime é uma variável do Unity que guarda o tempo em segundos que o computador demorou para calcular o último frame. Podemos utilizar esse valor para padronizar o movimento de objetos.\n\nvoid Update()\n{\n\ttransform.position += Vector3.right * Time.deltaTime;\n}\n\nO Script acima move o objeto para a direita todo frame. Ao multiplicar a distância movida por deltaTime, garantimos que ela será proporcional a taxa de quadros e igual em qualquer computador\n\nOBS: NEM SEMPRE O USO DE DELTATIME É TÃO SÍMPLES, E O EXEMPLO ACIMA SÓ SE APLICA À MOVIMENTO LINEAR (sem aceleração). CLIQUE AQUI PARA MAIS DETALHES SOBRE USO DE DELTATIME\n\nGeralmente, utilizar deltaTime é a forma mais versátil de garantir consistência no comportamento de seu jogo, porém pode ser complicado em algumas situações.\n\nFixedUpdate()\n\nFixedUpdate(), por outro lado, ocorre exatamente 60 vezes por segundo(configurável), por isso sempre é consistente entre máquinas*. Apesar disso, Time.fixedDeltaTime está disponível caso necessário.\n\n* Contanto que o computador seja capaz de calcular 60 quadros por segundo. Se esse não for o caso, Update() deve ser utilizado\n\nFixedUpdate() também tem outra característica importante: todo o cálculo de física em Unity (colisões, RigidBody, etc.) é feito nele, então é uma boa ideia colocar partes do código que interajam com a física dentro de FixedUpdate().\n\nDado isso, existe uma parte do código que é recomendada sempre estar em Update(): Input do usuário.\n\nUm exemplo de movimento horizontal usando Update() e FixedUpdate():\n\nRigidBody2D myRB;\nFloat InputX;\n\nvoid Start()\n{\n\tmyRB = GetComponent&lt;RigidBody2D&gt;();\n}\n\nvoid Update()\n{\n\tInputX = Input.GetAxis(\"Horizontal\");\n\t// Esse valor varia entre -1 (esquerda), 0 (parado) e 1(direita)\n}\n\nvoid FixedUpdate()\n{\n\tmyRB.velocity = new Vector2(InputX, 0);\n}\n\n",
        "url": "/CoralQuest/2024/08/31/Update-FixedUpdate.html"
      },
    
      {
        "title": "Raycasts",
        "excerpt": "Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.\n",
        "content": "Um raycast é, reduzidamente, uma linha traçada entre um ponto de origem e um de um ponto destino, a utilidade disto vem de que podemos detectar com quais objetos essa linha colidiu em seu trajeto.\n\nExemplos de uso de Raycast:\n\n  Determinar se um inimigo consegue ver o jogador quando há obstáculos no caminho\n  Saber se o jogador está olhando para um objeto interajível\n  Simular tiros de armas quando não queremos usar projéteis\n  Calcular o quão longe o jogador está do chão\n\n\nO último pode ser feito da seguinte forma:\n\nLayerMask chaoMask;\nfloat distanciaChao;\n\nvoid Start()\n{\n\tchaoMask = LayerMask.GetMask(\"Chao\");\n\t// Define uma máscara para a camada chão\n}\n\nvoid Update()\n{\n\tvar hit = Physics2D.Raycast(transform.position, Vector2.down, 100.0f, chaoMask)\n\t// Faz um Raycast da posição do jogador para baixo, com uma distância máxima de 100 unidades, que só pode colidir com objetos na camada Chao\n\t// a variável hit guarda as informações da primeira colisão desse raycast\n\t\n\tif(hit != null) // se o raycast recordou uma colisão, pegamos sua distância\n\t{\n\t\tdistanciaChao = hit.distance;\n\t}\n\telse\n\t{\n\t\tdistanciaChao = -1;\n\t}\n}\n\n",
        "url": "/CoralQuest/2024/09/01/Raycasts.html"
      },
    
      {
        "title": "Helper Classes & Extension Methods",
        "excerpt": "Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.\n",
        "content": "Às vezes, no nosso jogo, existem “funções” que precisamos utilizar em vários scripts diferentes. Ao invés de ter uma cópia dessa função em cada classe que precisa utilizá-la, podemos fazer uso de helper classes.\n\nUma helper Class é uma classe estática (pode ser chamada de qualquer parte do código) que guarda esse tipo de função que é útil em vários cenários.\n\nO Código a seguir implementa uma helper class com uma função que eleva um número ao quadrado e o divide por 3\n\npublic static class Helpers // note que essa classe não herda de MonoBehaviour\n{\n\tpublic static float SquareAndCut3(float x)\n\t{\n\t\treturn x * x / 3;\n\t}\n}\n\nEssa função pode então ser utilizada em outras classes:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tint a = 0;\n\tvoid Update()\n\t{\n\t\tDebug.Log(Helpers.SquareAndCut3(a));\n\t\ta++;\n\t\t// Imprime ao console o resultado da equação todo frame e incrementa o valor de entrada\n\t}\n}\n\nUma ideia similar à de Helper Classes é Extension Classes.\n\nNós não temos acesso ao código das classes já presentes no Unity (ex.: Transform, AudioSource, Vector3), porém existem situações em que seria conveniente adicionar uma função à uma dessas classes.\n\nPor exemplo, você pode achar que caso queira rotacionar um Vector2 em um ângulo específico, deve existir uma função Vector2.Rotate(angulo), porém essa função não existe.\nUma solução para isso seria implementar uma função RotateVector2() numa helper class, porém há uma solução mais elegante utilizando uma classe de extenção.:\n\npublic static class ExtensionMethods\n{\n\n\tpublic static void Rotate(this Vector2 vec, float delta) \t// O termo 'this' no primeiro argumento define que isso é uma extensão da classe Vector2\n\t{\n\t\tvec =  new Vector2(\n\t\t\tvec.x * Mathf.Cos(delta) - vec.y * Mathf.Sin(delta),\n\t\t\tvec.x * Mathf.Sin(delta) + vec.y * Mathf.Cos(delta)\n\t\t);\n\t}\n\n\n}\n\nPodemos então usar a função da seguinte forma:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tVector2 v;\n\tfloat angulo = 3.14159f;\n\t\n \tvoid Start()\n \t{\n \t\tv = new Vector2(1, 0);\n \t\tv.Rotate(angulo);\t// o primeiro argumento da função é o próprio vetor, não é necessário especificá-lo\n \t\tDebug.Log(v);\n \t\t// =&gt; (-1, 0)\n \t}\n}\n\n",
        "url": "/CoralQuest/2024/09/02/MetodosExtensao.html"
      },
    
      {
        "title": "Padrão Singleton",
        "excerpt": "Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.\n",
        "content": "Nem todos os objetos em Unity são criados da mesma forma, alguns tem maior importância. Você pode, por exemplo, ter um objeto GameManager, que possui funções como a de gameover, lida com o placar e mudanças de cena. Esse objeto será referenciado por várias classes pelo jogo, porém ele não pode ser estático, então referências à ele teriam que ser feitas da forma GameObject.Find(“Manager”) ou algo do tipo. Isso não é ideal, já que a função Find() não é eficiente, isso é o caso para a maioria das funções que atravéssam a hierarquia para encontrar um objeto, em graus diferentes.\n\nO GameManager possui uma característica que pode nos ajudar a referênciá-lo de forma eficiente, isto é o fato que só pode existir um destes objetos ativos em um dado momento. Isso nos possibilita o uso do padrão Singleton de design.\n\npublic class GameManager : MonoBehaviour\n{\n\t//\n\t//    ...\n\t//\n\tpublic int a = 3;\n\tpublic static GameManager Instance;\n\t\n\tvoid Awake()\t// Awake ocorre ainda antes do Start()\n\t{\n\t\tInstance = this;\n\t}\n\t\n\t//\n\t//    ...\n\t//\n\n}\n\nReferências ao GameManager podem então ser feitas assim:\n\npublic class MinhaClasse : MonoBehaviour\n{\n\tvoid Start()\n\t{\n\t\tDebug.Log(GameManager.Instance.a);\n\t\t// =&gt; 3\n\t}\n}\n\nMais sobre o padrão Singleton\n",
        "url": "/CoralQuest/2024/09/03/Singleton.html"
      },
    
  
  
  
  {
    "title": "Créditos",
    "excerpt": "\n",
    "content": "\n  Idealização - Carla Rocha\n\n\nConteúdo original\n\n  Programação - Laís Soares\n  Arte - Wonnz Lopes\n  Música - Herbert Kiragon\n  Efeitos Sonoros - Laís Soares, Wonnz Lopes, Herbert Kiragon\n\n\nAssets livres - Efeitos sonoros\n\n  pixabay\n  jofae\n  Sslc2022\n  LordSonny\n  floraphonic\n  UNIVERSFIELD\n  VoiceBosch\n    Assets livres - Música(menu e cena final)\n  \n  Pix\n\n\nPacotes Unity de terceiros\n\n  Fenerax Studios\n\n",
    "url": "/CoralQuest/creditos/"
  },
  
  {
    "title": "Bem vindo ao Coral Quest!",
    "excerpt": "\n",
    "content": "\n\nO que é Coral Quest?\nCoral Quest é um jogo criado como material de estudo de GameDev em Unity, e foi feito como continuação da Workshop Unity for Women, desenvolvida pela BOSS, a iniciativa da UnB com o objetivo de promover participação de minorias na comunidade Open Source.\n\nComo é o jogo?\nCoral quest é um platformer 2D, feito inteiramente com pixel art, de forma a lembrar jogos retro mais símples, o gameplay foi inspirado pelo gênero de Metroidvania, especialmente Hollow Knight, apesar de não ser muito longo.\n\nO jogo possui:\n\n  2 fases, sendo uma delas uma arena para boss fight\n  5 inimigos únicos\n  150+ Assets de uso livre, feitos por nós que incluem sprites e parte dos audios\n\n\n\n\nQual é a proposta do jogo?\nA partir do conteúdo da Workshop Unity for Women, os alunos encarregados desse projeto criaram um jogo aprofundando os conceitos e ferramentas básicas do Unity, com o objetivo de mostrar o que pode ser feito sem um conhecimento muito profundo da plataforma, enquanto ao mesmo tempo introduzindo novas ferramentas progressivamente.\n\n\n\nEssas ferramentas incluem:\n\n  Raycasts\n  Diferênciação do uso de Update (input) e FixedUpdate(física)\n  Tilemaps\n  Spritesheets para Animação\n  Cenas Aditivas\n  Extension Classes\n  Padrão de Design Singleton\n  Uso de várias câmeras simultâneamente\n  Interfaces(Orientação à Objetos)\n\n\nUnity\nFoi usada a versão 2021.3.25f1 do editor Unity com o template 2D, e essa é a versão recomendada ao rodar o projeto.\n\n\n\nTambém foi utilizado o pacote Universal Render Pipeline(URP).\n\nLicensa\nO Repositório e jogo são disponibilizados sobre a licensa MIT .\n\n",
    "url": "/CoralQuest/"
  },
  
  {
    "title": "Sobre",
    "excerpt": "\n",
    "content": "Lmao\n",
    "url": "/CoralQuest/about/"
  },
  
  {
    "title": "Tutoriais",
    "excerpt": "\n",
    "content": "Estes tutoriais assumem um conhecimento das ferramentas básicas do Unity, que podem ser vistas em BOSS:Unity for women.\n\n",
    "url": "/CoralQuest/tutoriais/"
  }
  
]

